# Сортировщики FLINT

Утилиты сортировки координат для системы лазерной гравировки **FLINT**.

## Структура

```
Utils/
├── GENESIS/                — оригинальные файлы
│   ├── CFTSORT.EXE         — оригинальный 16-битный EXE
│   ├── BFTSORT.EXE         — оригинальный 16-битный EXE
│   └── fromviz.cft         — тестовые данные (33944 точки)
├── SRC/                    — исходный код
│   ├── CFTSORT.CPP         — восстановленный оригинал: CFT → BFT (BC45, 16-bit)
│   ├── BFTSORT.CPP         — восстановленный оригинал: BFT → BFT (BC45, 16-bit)
│   ├── CFTSORT-32BIT.CPP   — улучшенный: CFT → BFT (Watcom, Win32)
│   ├── BFTSORT-32BIT.CPP   — улучшенный: BFT → BFT (Watcom, Win32)
│   ├── COMPILE.bat         — сборка всех 4 EXE
│   └── BUILD/              — скомпилированные EXE (создаётся при сборке)
└── README.md

Tools/
├── BC45/                   — Borland C++ 4.5 (16-битный компилятор DOS)
├── DOSBox-X/               — DOSBox-X (эмулятор DOS для 64-битных Windows)
└── WATCOM/                 — Open Watcom C++ V2
    ├── binnt/              — 32-битные исполняемые файлы компилятора
    ├── binnt64/            — 64-битные исполняемые файлы компилятора
    ├── h/                  — заголовочные файлы
    └── lib386/             — библиотеки (nt/, root)
```

## Две версии

### Оригиналы (CFTSORT.EXE / BFTSORT.EXE)

- Исходный код **восстановлен** из EXE полным дизассемблированием
- 16-битный DOS, Borland C++ 4.5 (1994), Large memory model
- Nearest-neighbor O(N²), лимит ~80K точек
- Компиляция через `SRC\COMPILE.bat`

### Улучшенные (CFTSORT32.EXE / BFTSORT32.EXE)

- Win32 console PE — работает на Windows 95 — Windows 11
- Open Watcom C++, без ограничений по памяти (до 16M точек)
- Grid-accelerated nearest-neighbor O(N√N) + or-opt
- ~20% улучшение длины пути на реальных данных
- Компиляция через `SRC\COMPILE.bat`

## Сборка

```bat
cd Utils\SRC
COMPILE.bat
```

Единый скрипт компилирует все 4 EXE:

| Исходник | Результат | Компилятор |
|----------|-----------|------------|
| CFTSORT.CPP | BUILD\CFTSORT.EXE | Borland C++ 4.5 (16-bit DOS) |
| BFTSORT.CPP | BUILD\BFTSORT.EXE | Borland C++ 4.5 (16-bit DOS) |
| CFTSORT-32BIT.CPP | BUILD\CFTSORT32.EXE | Open Watcom C++ (Win32 PE) |
| BFTSORT-32BIT.CPP | BUILD\BFTSORT32.EXE | Open Watcom C++ (Win32 PE) |

- **Borland 16-бит**: на 32-битных Windows компилирует нативно, на 64-битных — через DOSBox-X
- **Watcom 32-бит**: компилирует нативно, `binnt\` на 32-битных ОС, `binnt64\` на 64-битных

## Формат CFT (текстовый)

```
flinttab
nglass=	1.506
xsize=	50
ysize=	50
zsize=	50
1:	-4888	3092	-19
2:	-4863	3075	-19
...
```

- Строка 1: магическая строка `flinttab`
- Строки 2–5: параметры (показатель преломления, размеры в мм)
- Данные: `N:\tX\tY\tZ` — целочисленные координаты через табуляцию

## Формат BFT (бинарный)

| Смещение | Тип | Описание |
|----------|------|----------|
| 0 | int16 | `0x6662` ("bf") — магическая сигнатура |
| 2 | int16 | nglass × 1000 (например, 1506 для n=1.506) |
| 4 | int16 | xsize (в единицах 0.1 мм, = CFT значение × 10) |
| 6 | int16 | ysize |
| 8 | int16 | zsize |
| 10 | int16 | зарезервировано (старшее слово npoints, обычно 0) |
| 12 | int16 | количество точек N (младшее слово) |
| 14 | int16[N×3] | данные: x, y, z на каждую точку (6 байт/точка) |

## Алгоритм сортировки

### Оригинальный (CFTSORT / BFTSORT)

Nearest-neighbor O(N²):

1. Найти точку с минимальным Z → позиция 0
2. Для каждой позиции i: найти ближайшую непосещённую точку по δ → позиция i+1

### Улучшенный (CFTSORT32 / BFTSORT32)

Grid NN + or-opt:

1. **Phase 1 (min-Z)** — то же, что в оригинале
2. **Phase 2 (grid NN)** — nearest-neighbor с пространственной сеткой:
   - Bounding box → ячейки (~25 точек/ячейка), hash-grid с bucket chains
   - Поиск: расширяющиеся кольца, отсечение `(ring-1) × cell_size - max_z_bonus > best_δ`
   - Сложность O(N√N) вместо O(N²)
3. **Phase 3 (or-opt)** — локальный поиск:
   - Извлекает цепочки из 1, 2, 3 точек и вставляет в лучшую позицию
   - Оконный поиск ±500 позиций, до 5 проходов
   - Двусвязный список → O(1) на перестановку
   - Без реверса → **корректно для асимметричной метрики**

**Почему or-opt, а не 2-opt?**

2-opt реверсирует сегмент, что меняет знак dz. Поскольку K_up ≠ K_down,
метрика асимметрична (ATSP), и реверс делает «дешёвые» рёбра «дорогими».
Or-opt перемещает цепочки без реверса — корректен для ATSP.

### Формула расстояния (delta)

Подтверждено дизассемблированием (calc_delta @ 0x905C):

```
δ = max(|dx|, |dy|) + (dz × K) / 10
```

- `K = K_up` при `dz > 0` — штраф за движение вверх
- `K = K_down` при `dz ≤ 0` — бонус за движение вниз
- Деление на 10 — целочисленное (idiv)

## Параметры командной строки

```
CFTSORT[32] source.cft dest.bft K_up K_down
BFTSORT[32] source.bft dest.bft K_up K_down
```

- `K_up` / `K_down` — коэффициенты Z (1–1000), типичные значения: `14 10`

## Особенности реализации

### Оригинал (16-бит, Borland)

- Память: `farmalloc(coreleft() - 30000)`, макс. ~80–90K точек
- Массив: плоский `int far *`, 3 × int16 на точку
- I/O: `fwrite(data, 12, ceil(N/2), fp)` — запись парами
- Сортировка: brute-force NN O(N²)

### Улучшенный (32-бит, Watcom)

- Память: `malloc`/`realloc`, до 16M точек
- Пространственный индекс: hash-grid, ~25 точек/ячейка
- Tour: двусвязный список (O(1) insert/remove)
- NN: grid + ring pruning, O(N√N)
- Or-opt: цепочки len=1,2,3, окно ±500, до 5 проходов
- Прогресс: по фазам, ESC для прерывания

## Результаты компиляции оригиналов

| Файл | Оригинал (GENESIS) | Скомпилировано | Разница |
|------|----------|----------------|---------|
| CFTSORT.EXE | 58756 байт | 59044 байт | +288 (+0.5%) |
| BFTSORT.EXE | 42756 байт | 42850 байт | +94 (+0.2%) |

Совпадение подтверждено: enter-инструкции, inline abs(), idiv 10, startup-код,
строка "Borland C++ - Copyright 1994 Borland Intl".

## Метод восстановления

Исходный код воссоздан на основе полного дизассемблирования EXE-файлов:

1. 16-битное дизассемблирование (capstone, CS_ARCH_X86, CS_MODE_16)
2. Трассировка calc_delta (0x905C–0x91BC): abs через `cwd; xor; sub`, деление `idiv 10`
3. Анализ цикла сортировки (0x8C31–0x905B): Phase 1 (min-Z) + Phase 2 (NN)
4. Анализ I/O: read_cft (0x92BC), write_bft (0x95F9)
5. Декодирование FPU-эмуляции: INT 34h–3Fh → x87 (Borland emulation)
6. Извлечение строковых констант и глобальных переменных (DS: 0xB54–0xB70)
7. Кросс-верификация BFTSORT.EXE (calc_delta @ 0x833B — идентичная формула)
8. Бинарное сравнение: структурная идентичность кода подтверждена
